---
title: "Docker + Rust"
date: 2020-10-29T11:39:31+01:00
draft: true
---
In this post we're gonna look at how you can package rust projects in docker and cache cargo dependencies for faster subsequent builds.

## Prerequisites
- Rust installed
- Docker installed

## Getting started
Before we can dive into docker we first have to create a new cargo project.
In this post we're gonna take the default "Hello World" that gets generated by cargo.
To get started run `cargo new --bin rusty-docker`. This should create a directory called
`rusty-docker` with a `src/main.rs`-file. If we run it with `cargo run` we get `Hello World!`.

## Packaging the binary with docker
Rust provides us with a base-image that comes with `rustc` and `cargo` out of the box.
We base our image of of the rust-one. The first version of our Dockerfile looks like this:
```Dockerfile
FROM rust:latest

WORKDIR /usr/src/app
COPY Cargo.toml Cargo.toml
COPY . .

RUN cargo build --release

CMD ["target/release/rusty-docker"]
```
Now build and run the container:
```bash
docker build -t rusty-docker .
docker run -it rusty-docker
```
This should give you `Hello World!`, the same output as without docker.

## Adding a dependency
To demonstrate how we can cache dependencies we're gonna add serde as a dependency to our Cargo.toml.
```yaml
[package]
name = "rusty-docker"
version = "0.1.0"
authors = ["Yves Savoy <10594588+yvessavoy@users.noreply.github.com>"]
edition = "2018"

[dependencies]
serde = { version = "1", features = ["derive"] }
```

When you run `docker build -t rusty-docker .` it builds serde. If you change one of your source files and build the image again, it will compile serde as if it was not there. This is because Docker invalidates all layers and thus, looses the compiled dependency.

## Cache dependencies
Cargo currently does not come with an option to download and compile all dependencies without any
source code. We can now hack our way around this to still achieve the caching of dependencies.
To get this we'll do the following:
- Create an empty main.rs so cargo thinks our source code is there
- Copy over the Cargo.toml file
- Build the project with the empty main.rs
- Copy over all of our actual source code
- Build again

In docker it will look like this:
```Dockerfile
FROM rust:latest

# Switch to an appropirate dir
WORKDIR /usr/src/app

# Create our "fake" main.rs
RUN mkdir src
RUN echo "fn main() {}" > src/main.rs

# Copy over the Cargo-file
COPY Cargo.toml Cargo.toml

# Build the dependencies
RUN cargo build --release

# Delete the fake build
RUN rm -f target/release/deps/rusty_docker*

# Copy over our actual source
COPY . .

# Build the final binary
RUN cargo build --release

CMD ["target/release/rusty-docker"]
```

This will cache all dependencies. As soon as you change your Cargo.toml-file docker will
invalidate all cached layers and rebuild the dependencies.
The line that allows us to build our source from scratch is this:
```Dockerfile
RUN rm -f target/release/deps/rusty_docker*
```
This removes the built binary which causes cargo to rebuild it on the second `cargo build --release`.

## Create smaller images
The whole rust-toolchain (rustc, cargo, etc.) is only needed for building, but not for actually
running your application. This means that we can reduce the size of our final image by using a
builder to compile the project, then copy over the finally binary into a smaller image with, for
example, alpine as the base image. Currently our image is 1.42 GB in size:
```bash
rusty-docker  latest  8bb03151808e  4 minutes ago  1.42GB
```
First of all we can exclude our local target-folder from the image. Create a `.dockerignore`-file as follows: `echo "target" > .dockerignore`.

Second, we can introduce a builder to our dockerfile. Because we're gonna use alpine in the final image, we need to compile our binary against musl-libc. This is explained further down. For now, the final Dockerfile looks like this:
```Dockerfile
# ------------------------
# Build Image
# ------------------------
FROM rust:latest as builder

RUN apt-get update && apt-get install musl-tools -y
RUN rustup target add x86_64-unknown-linux-musl

# Switch to an appropriate dir
WORKDIR /usr/src/app

# Copy over the Cargo-file
COPY Cargo.toml Cargo.toml

# Create our "fake" main.rs
RUN mkdir src
RUN echo "fn main() { }" > src/main.rs

# Build the dependencies
RUN RUSTFLAGS=-Clinker=musl-gcc cargo build --release --target=x86_64-unknown-linux-musl

# Delete the fake build
RUN rm -f target/x86_64-unknown-linux-musl/release/deps/rusty_docker*

# Copy over our actual source
COPY . .

# Build the final binary
RUN RUSTFLAGS=-Clinker=musl-gcc cargo build --release --target=x86_64-unknown-linux-musl

# ------------------------
# Final Image
# ------------------------
FROM alpine:latest

WORKDIR /home/app
COPY --from=builder /usr/src/app/target/x86_64-unknown-linux-musl/release/rusty-docker .

CMD ["./rusty-docker"]
```

The important line is:
```Dockerfile
COPY --from=builder /usr/src/app/target/x86_64-unknown-linux-musl/release/rusty-docker .
```

This will copy the compiled binary from the previous stage, but excludes the rust-toolchain itself. The final binary size is now much smaller:
```bash
rusty-docker  latest  c49608417b4a  2 hours ago  9.25MB
```

Now let's look at the lines needed for compiling against musl-libc. First, we install the musl-tools:
```Dockerfile
RUN apt-get update && apt-get install musl-tools -y
```

Then we add the musl-target to our rust-toolchain:
```Dockerfile
RUN rustup target add x86_64-unknown-linux-musl
```

Finally, we tell cargo which linker to use and against which target it should compile:
```Dockerfile
RUN RUSTFLAGS=-Clinker=musl-gcc cargo build --release --target=x86_64-unknown-linux-musl
```

## Conclusion
We now have a small and efficient image which only recompiles dependencies when needed.
This allows for faster compilation when using docker during development. Hopefully cargo will add
an option soon to compile dependencies on their own, but for now this seems to be the only way to
get cached dependencies in docker.

Thanks for reading!
